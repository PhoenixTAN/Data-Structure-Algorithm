# 模拟LRU 缓存机制
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。

写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

### 进阶:
你是否可以在 O(1) 时间复杂度内完成这两种操作？

### 示例:
```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```
## 如何实现LRU的更新：双向链表 Doubly Linked List

Intuition: 越靠近链表开头的元素，越常用；越靠近链表解位的元素，越不常用；

1. 为什么是双向？第一，方便删除；第二，方便取链表末端元素并删除。
2 当一个Node被加入、更新、修改的时候，都会被放到这个链表的最开头。
3 当Cache缓存已经满了，链表末端元素会被删除。

## 如何实现HashMap
源码的大制做法（只是笔者的理解）：位桶+链表/红黑树。  
当链表长度超过8，该链表就会转成红黑树。
